# 冒泡排序
## 原理：
- 比较两个相邻的元素，将值大的元素交换至右端。

## 思路：
- __依次比较相邻的两个数，将较小的数放在左端，较大的数放在右端。__ 即在第一趟：首先比较第1个数和第2个数，将较小的数放前，较大的数放后；然后比较第2个数和第3个数，将较小的数放前，较大的数放后；......直至最后的两个数比较完，并将较小的数放前，较大的数放后；重复第一趟步骤，直至全部排序完成。

- __举例说明__：待排序的数组：int[] arr={6,4,8,2,9,1};   

---

>第一趟排序：

| 排序次数 | 下标相邻元素的比较 | 是否互换位置 | 互换后的排序 |
|-|-|-|-|
|   1   |       6>4       |     Y    | 4  6  8  2  9  1 |
|   2   |       6<8       |     N    |  |
|   3   |       8>2       |     Y    | 4  6  2  8  9  1 |
|   4   |       8<9       |     N    |  |
|   5   |       9>1       |     Y    | 4  6  2  8  1  9 |

---

>第二趟排序：

| 排序次数 | 下标相邻元素的比较 | 是否互换位置 | 互换后的排序 |
|-|-|-|-|
|   1   |       4<6       |     N    |  |
|   2   |       6>2       |     Y    | 4  2  6  8  1  9 |
|   3   |       6<8       |     N    |  |
|   4   |       8>1       |     Y    | 4  2  6  1  8  9 |

---

>第三趟排序：

| 排序次数 | 下标相邻元素的比较 | 是否互换位置 | 互换后的排序 |
|-|-|-|-|
|   1   |       4>2       |     Y    | 2  4  6  1  8  9 |
|   2   |       4<6       |     N    |  |
|   3   |       6>1       |     Y    | 2  4  1  6  8  9 |

---

第四趟排序：

| 排序次数 | 下标相邻元素的比较 | 是否互换位置 | 互换后的排序 |
|-|-|-|-|
|   1   |       2<4       |     N    |  |
|   2   |       4>1       |     Y    | 2  1  4  6  8  9 |

---

第五趟排序：

| 排序次数 | 下标相邻元素的比较 | 是否互换位置 | 互换后的排序 |
|-|-|-|-|
|   1   |       2>1       |     Y    | 1  2  4  6  8  9 |


---------------------------------------------------------------------

最终结果：1  2  4  6  8  9

---------------------------------------------------------------------

### 由此可见：

N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即

```java
for(int i=1;i<arr.length;i++){
    for(int j=1;j<arr.length-i;j++){
        //交换位置   
    }   
} 
```

### 冒泡排序的优点：
__每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。__ 如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，每进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。

### 时间复杂度：
    1.若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 __C__ 和记录移动次数 __M__ 均达到最小值Cmin=n-1,Mmin=0；
      所以，冒泡排序最好的时间复杂度为O(n)。

    2.若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。
    在这种情况下，比较和移动次数均达到最大值：Cmax=(n*(n-1))/2=O(n^2)；Mmax=(3n*(n-1))/2=O(n^2)；所以，冒泡排序最坏的时间复杂度为O(n^2)。
    
    综上，因此冒泡排序总的平均时间复杂度为 O(n^2)。

### 代码实现冒泡排序：
```java
public class BubbleSort {
　　public static void main(String[] args) {
　　　　int[] arr={6,4,8,2,9,1};
　　　　System.out.println("排序前数组为：");
　　　　for(int num:arr){//遍历数组
　　　　　　System.out.print(num+" ");
　　　　}
　　　　for(int i=0;i<arr.length-1;i++){//外层循环控制排序趟数
　　　　　　for(int j=0;j<arr.length-1-i;j++){//内层循环控制每一趟排序多少次
　　　　　　　　if(arr[j]>arr[j+1]){
　　　　　　　　　　int temp=arr[j];
　　　　　　　　　　arr[j]=arr[j+1];
　　　　　　　　　　arr[j+1]=temp;
　　　　　　　　}
　　　　　　}
　　　　} 
　　　　System.out.println();
　　　　System.out.println("排序后的数组为：");
 　　　　for(int num:arr){
 　　　　　　System.out.print(num+" ");
 　　　　} 
　　}
 }
 ```
